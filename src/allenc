#!/usr/bin/perl
# Copyright 2018,2019 Inria. This file is part of Allen.
#
# Allen is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Allen is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Allen.  If not, see <https://www.gnu.org/licenses/>.

#
# Compiler for the Allen DSL.
#

my $usage = "usage: allenc [options] file.aln
where:
* file.aln contains a program in the Allen DSL
* options are the following ones:
  -o outfile: Output the compiled Perl module in outfile
  -s: Print the syntax of the language and exit
  -l: List all native operators and exit
  -L: List all native operators with their help and exit
  -h operator: Print help on the given operator and exit";

# Allen syntax:

my $syntax =
'
  Prog -> Use* Lib LetRules
  Use -> "use" id ("[" int "]")? ("(" int ")")?
  Lib -> Def*
  Def -> "def" id ("[" id+(",") "]")? ("(" id*(",") ")")? str*
         "=" Context
  LetRules -> "let" id "=" Expr "in" LetRules | Rules
  Rules -> id ":" Context (";" Rules)?
  Context -> "let" id "=" Expr "in" Context | Expr
  Expr -> Prod "|" Expr | Prod
  Prod -> Comp "&" Prod | Comp
  Comp -> Expr1 (">=!"|"<="|">="|">!"|">!!"|"<"|">") Int | Expr1
  Expr1 -> true | false | "~" Expr1 | "(" Expr ")" | str
        | id ("[" Int+(",") "]")? ("(" Expr*(",") ")")?
  Int -> Int1 ("+"|"-") Int | Int1
  Int1 -> id | int ("hr" | "min" | "sec")?

Notes:
* Comments in the program start with a "#" and span to the end of line.';

# NB: removed str case from Int

# Infix and prefix operators
my %fix = (
"&" => "p & q is the binary 'and' boolean operator,
(p&q)(t) <-> p(t) & q(t)",
"|" => "p | q is the binary 'or' boolean operator,
(p|q)(t) <-> p(t) or q(t)",
"~" => "~p is the unary 'not' boolean operator,
(~p)(t) <-> not p(t)",
"<" => "p < T selects the states of p shorter than T,
{[t,t') in p | t'-t < T}",
">" => "p > T selects the states of p longer than T,
{[t,t') in p | t'-t > T}",
"<=" => "p <= T selects the states of p lasting at most T,
{[t,t') in p | t'-t <= T}",
">=" => "p >= T selects the states of p lasting at least T,
{[t,t') in p | t'-t >= T}",
">=!" => "p >=! T selects the beginnings of states in p >= T, shortened to T,
{[t,t+T) | [t,t') in p & t'-t >= T}",
">!" => "p >! T selects the beginnings of states in p > T, shortened to T,
{[t,t+T) | [t,t') in p & t'-t > T}",
">!!" => "p >!! T selects the ends of states in p > T, after dropping p >! T,
{[t+T,t') | [t,t') in p & t'-t > T}",
);

my %predef = (
"id" => [0,1, "id(p) is the identity function for signals"],
"LT" => [1,1, "LT[T](p) is the prefix notation for p < T"],
"LE" => [1,1, "LE[T](p) is the prefix notation for p <= T"],
"GT" => [1,1, "GT[T](p) is the prefix notation for p > T"],
"GE" => [1,1, "GE[T](p) is the prefix notation for p >= T"],
"GTrt" => [1,1, "GTrt[T](p) is the prefix notation for p >! T"],
"GErt" => [1,1, "GErt[T](p) is the prefix notation for p >=! T"],
"since" => [0,2,
"since(p,q) is the strong Since operator in LTL,
since(p,q)(t) <-> exists t'<=t . q(t') & p is 1 on (t',t]"],
"until" => [0,2,
"until(p,q) is the strong Until operator in LTL,
until(p,q)(t) <-> exists t'>=t . q(t') & p is 1 on [t,t')"],
"wsince" => [0,2, "wsince(p,q) is the weak Since operator in LTL,
wsince(p,q)(t) <-> since(p,q)(t) or forall t'<=t . p(t')"],
"wuntil" => [0,2, "wuntil(p,q) is the weak Until operator in LTL,
wuntil(p,q)(t) <-> until(p,q)(t) or forall t'>=t . p(t')"],
"O" => [0,1, "O(p) is the Once operator in LTL,
O(p)(t) <-> exists t'<=t . p(t')"],
"H" => [0,1, "H(p) is the Historically operator in LTL,
H(p)(t) <-> forall t'<=t . p(t')"],
"F" => [0,1, "F(p) is the Finally operator in LTL,
F(p)(t) <-> exists t'>=t . p(t')"],
"G" => [0,1, "G(p) is the Globally operator in LTL,
G(p)(t) <-> forall t'>=t . p(t')"],
"init" => [0,1,
"init(p) selects the initial state of p (starting at t=0), if there is one,
{[0,t') | [0,t') in p}"],
"O_le" => [1,1, "O_le[T](p) is the bounded Once[0,T] operator in MTL,
O_le[T](p)(t) <-> exists t'. t-t' in [0,T] and p(t')"],
"H_le" => [1,1, "H_le[T](p) is the bounded Historically[0,T] operator in MTL,
H_le[T](p)(t) <-> forall t'. t-t' in [0,T] -> p(t')"],
"during" => [0,2,
"during(p,q) selects the states of p strictly contained in some state of q,
{[t,t') in p | [t'',t''') in q & t''<t<t'<t'''}"],
"contains" => [0,2,
"contains(p,q) selects the states of p strictly containing some state of q,
{[t,t') in p | [t'',t''') in q & t<t''<t'''<t'}"],
"over" => [0,2,
"over(p,q) selects the intersections between states of p overlapping some state
of q,
{[t'',t') | [t,t') in p & [t'',t''') in q & t<t''<t'<t'''}"],
"overlaps" => [0,2,
"overlaps(p,q) selects the states of p overlapping some state of q,
{[t,t') in p | [t'',t''') in q & t<t''<t'<t'''}"],
"overlapped" => [0,2,
"overlapped(p,q) selects the states of p overlapped by some state of q,
{[t,t') in p | [t'',t''') in q & t''<t<t'''<t'}"],
"starts" => [0,2,
"starts(p,q) selects the states of p starting some state of q,
{[t,t') in p | [t,t'') in q & t'<t''}"],
"started" => [0,2,
"started(p,q) selects the states of p started by some state of q,
{[t,t') in p | [t,t'') in q & t''<t'}"],
"ends" => [0,2,
"ends(p,q) selects the states of p ending some state of q,
{[t,t') in p | [t'',t') in q & t''<t}"],
"ended" => [0,2,
"ended(p,q) selects the states of p ended by some state of q,
{[t,t') in p | [t'',t') in q & t<t''}"],
"eq" => [0,2,
"eq(p,q) selects the states of p equal to some state of q,
{[t,t') in p | [t,t') in q}"],
"meets" => [0,2,
"meets(p,q) selects the states of p meeting some state of q,
{[t,t') in p | [t',t'') in q}"],
"met" => [0,2,
"met(p,q) selects the states of p met by some state of q,
{[t,t') in p | [t'',t) in q}"],
"between" => [0,2,
"between(p,q) selects the intervals between a state in p and the next state in q,
{[t',t'') | [t,t') in p & [t'',t''') in q & t'<t'' &
            any later state of p ends strictly after t'' &
            any earlier state of q starts strictly before t'}"],
"before" => [0,2,
"before(p,q) selects the states of p immediately before some state of q,
{[t,t') in p | [t',t'') in between(p,q)}"],
"after" => [0,2,
"after(p,q) selects the states of p immediately after some state of q,
{[t,t') in p | [t'',t') in between(p,q)}"],
"btwin" => [0,2,
"btwin(p,q) selects the quiet intervals between a state in p and the next state
in q,
{[t',t'') | [t,t') in p & [t'',t''') in q & t'<t'' &
            p is 0 on [t',t'') & q is 0 on (t',t'')"],
"btw" => [0,2,
"btw(p,q) selects the fully quiet intervals between a state in p and the next
state in q,
{[t',t'') | [t,t') in p & [t'',t''') in q & t'<t'' &
            p is 0 on [t',t''] & q is 0 on [t',t'')"],
"holds" => [0,2,
"holds(p,q) selects the states of q where p always holds,
{[t,t') in q | forall t'' in [t,t') . p(t'')}"],
"ex" => [0,2,
"ex(p,q) selects the states of q where p occurs at least once,
{[t,t') in q | exists t'' in [t,t') . p(t'')}"],
"occ" => [0,2,
"occ(p,q) selects the ends of states of q where p has already occurred,
{[t'',t') | [t,t') in q & exists t'' in [t,t') . p(t'') & p is 0 on [t,t'')}"],
"true" => [0,0, "true is the constant signal always 1,
{[0,inf)}"],
"false" => [0,0, "false is the constant signal always 0,
{}"],
"delay" => [1,1,
"delay[T](p) produces the signal p delayed by T>0, padded with 0 at the origin,
{[t+T,t'+T) | [t,t') in p}"],
"cut" => [1,1,
"cut[T](p) selects all the states of p, shortened to T if longer,
{[t,min(t',t+T)) | [t,t') in p}"],
"recent" => [1,1,
"recent[T](p) is true whenever p has occurred in the last T,
recent[T](p)(t) <-> exists t'>0 in [t-T,t] . p(t')"],
"step" => [1,0,
"step[T] is the step function, 0 until T and 1 starting at T,
{[T,inf)}"],
"orig" => [0,0,
"orig() is true only at the origin (at t=0),
{[0,1)}"],
"wave" => [4,0,
"wave[T0,T1,Ts,Te] generates a periodic wave signal which is 0 during T0, then
1 during T1, starting at Ts and ending at Te,
{[Ts+(T0+T1)*n+T1,Ts+(T0+T1)*(n+1)) | n>=0 & Ts+(T0+T1)*n+T1 < Te }"],
"slot" => [6,0,
"slot[Tf,Tt,Ts,Te,S,W] generates a daily slot lasting each day from Tf to Tt,
starting at Ts, ending at Te, and switching to summer time as S and back at W"],
"slot_dst_2017" => [2,0,
"slot_dst_2017[Tf,Tt] generates a daily slot for the whole year 2017, lasting
each day from Tf to Tt"],
"slot_dst_2018" => [2,0,
"slot_dst_2017[Tf,Tt] generates a daily slot for the whole year 2018, lasting
each day from Tf to Tt"],
"up" => [0,1,
"up(p) is true whenever p starts being 1, excluding t=0,
{[t,t+1) | [t,t') in p & t>0}"],
"dn" => [0,1,
"dn(p) is true whenever p starts being 0, excluding t=0,
{[t,t+1) | [t',t) in p}"],
"up0" => [0,1,
"up0(p) is true whenever p starts being 1, possibly including t=0,
{[t,t+1) | [t,t') in p}"],
"dn0" => [0,1,
"dn0(p) is true whenever p starts being 0, possibly including t=0,
{[t,t+1) | [t',t) in p or (t=0 & not p(t))}"],
"sw" => [0,1,
"sw(p) is true whenever p switches value,
sw(p)(t) <-> up(t) or dn(t)"],
"all" => [0, undef, "all(s1,...sN) is an N-ary boolean and"],
"any" => [0, undef, "any(s1,...sN) is an N-ary boolean or"],
"any_up" => [0, undef,
"any_up(s1,...sN) is true whenever some of the signals becomes 1"],
"any_dn" => [0, undef,
"any_dn(s1,...sN) is true whenever some of the signals becomes 0"],
"any_sw" => [0, undef,
"any_sw(s1,...sN) is true whenever some of the signals switches its value"],
"first" => [0,2,
"first(p,q) selects the first state of p starting or during some state of q"],
"fill" => [0,2, "fill(p,q) fills holes between p's within q"],
"flat" => [0,2, "flat(p,q) collapses all p's during q"],
"flat_right" => [0,2,
"flat_right(p,q) extends flat rightwards to end of slot q if p reaches the
end of slot"],
"occ_before" => [0,3,
"occ_before(p,q,slot) is true between the moments when p, then q occur for the
1st time in the slot"]
);

use Getopt::Std;
our %opts = ();

getopts('o:slLh:', \%opts) or die "$usage\n";

if (defined($opts{'s'})) {
  print "The syntax of the Allen language is:\n";
  print "$syntax\n";
  exit;
}

if (defined($opts{'l'})) {
  print "The predefined operators are:\n";
  for my $k (sort keys %fix) {
    print "$k ";
  }
  for my $k (sort keys %predef) {
    print "$k ";
  }
  print "\nUse option '-h <op>' for printing help on operator <op>\n";
  exit;
}

if (defined($opts{'L'})) {
  print "Native Allen operators and their semantics:\n\n";
  for my $k (sort keys %fix) {
    print "$fix{$k}\n\n";
  }
  for my $k (sort keys %predef) {
    print "$predef{$k}->[2]\n\n";
  }
  exit;
}

if (defined($opts{'h'})) {
  my $op = $opts{'h'};
  if (exists($predef{$op})) {
    print "$predef{$op}->[2]\n";
  } elsif (exists($fix{$op})) {
    print "$fix{$op}\n";
  } else {
    die "$op is not a predefined operator"
  }
  exit;
}

die "$usage\n" if @ARGV == 0 || @ARGV > 1;

my $infile = $ARGV[0];
die "$usage\n" if $infile !~ /[.]aln$/;

my $outfile;
if (defined($opts{'o'})) {
  $outfile = $opts{'o'};
} else {
  $outfile = $infile;
  $outfile =~ s/[.]aln$/.pm/;
}

open(IN, "<", $infile) or
  die "cannot open input file \"$infile\"\n";

open(OUT, ">", $outfile) or
  die "cannot open output file \"$outfile\"\n";

my $line = "";

# while (1) {
#   my ($typ, $tok) = &token(1);
#   last if $typ eq "eof";
#   print "$tok: $typ\n";
# }
# print "done\n";
# exit;

my %use = (); # symbol table for use's (global scope)
my %def = (); # symbol table for def's (global scope)
my %glb = (); # symbol table for global lets (global scope)
my %var = (); # symbol table for variables (lexical scope)

&parse_uses();
my $l = &parse_lib();
#&print_ast($l);
#print "\n";
my $p = &parse_let_rules();
#&print_ast($p);
#print "\n";

print OUT "# User-defined operators\n\n";
for my $d (@$l) {
  &gen_def($d);
}
&gen_let_rules($p);
exit;

# ----------------- parsing ---------------------

sub parse_uses() {
  my ($typ, $tok) = &token(0); # look ahead
  while ($typ eq "key" && $tok eq "use") {
    &token(1); # consume "use`"
    my ($typ2, $tok2) = &token(1);
    die "id expected in use, found $tok2 at $line"
      if $typ2 ne "id";
    my $name = $tok2;
    my $npars = 0;
    my $nargs = 0;
    die "duplicated use: $name" if defined($uses{$name});
    my ($typ3, $tok3) = &token(0); # lookahead
    if ($typ3 eq "key" && $tok3 eq "[") {
      &token(1); # consume '['
      my ($typ4, $tok4) = &token(1);
      die "int expected in def, found $tok4 at $line"
        if $typ4 ne "int";
      $npars = $tok4;
      ($typ3, $tok3) = &token(1);
      die "expected closing par, found: $tok3"
        if $typ3 ne "key" || $tok3 ne "]";
    }
    ($typ3, $tok3) = &token(0); # lookahead
    if ($typ3 eq "key" && $tok3 eq "(") {
      &token(1); # consume '('
      my ($typ5, $tok5) = &token(1);
      die "int expected in def, found $tok5 at $line"
        if $typ5 ne "int";
      $nargs = $tok5;
      ($typ3, $tok3) = &token(1);
      die "expected closing par, found: $tok3 at $line"
        if $typ3 ne "key" || $tok3 ne ")";
    }
    $use{$name} = [$npars, $nargs];
    ($typ, $tok) = &token(0); # look ahead
  }
}

sub parse_lib() {
  my @defs = ();
  my ($typ, $tok) = &token(0); # look ahead
  while ($typ eq "key" && $tok eq "def") {
    my $d = &parse_def();
    push @defs, $d;
    my $nm = $d->[1];
    die "duplicated def: $nm" if defined($def{$nm});
    my $npar = @{$d->[2]};
    my $narg = @{$d->[3]};
    my $strs = @{$d->[4]};
    $def{$nm} = [$npar, $narg, $strs]; # put name in def symbol table
    ($typ, $tok) = &token(0); # look ahead
  }
  return \@defs;
}

sub parse_def() {
  %var = (); # reset let symbol table
  my ($typ, $tok) = &token(1);
  die "def expected, found $tok at $line"
    if $typ ne "key" || $tok ne "def";
  my ($typ2, $tok2) = &token(1);
  die "id expected in def, found $tok2 at $line"
    if $typ2 ne "id";
  my @pars = ();
  my ($typ3, $tok3) = &token(0); # lookahead
  if ($typ3 eq "key" && $tok3 eq "[") {
    &token(1); # consume '['
    do {
      my ($typ4, $tok4) = &token(1);
      die "id expected in def, found $tok4 at $line"
        if $typ4 ne "id";
      push @pars, $tok4;
      die "duplicated variable $tok4" if defined($var{$tok4});
      $var{$tok4} = "par"; # register parameter
      ($typ3, $tok3) = &token(1);
    } while ($typ3 eq "key" && $tok3 eq ",");
    die "expected closing par, found: $tok3"
      if $typ3 ne "key" || $tok3 ne "]";
  }
  my @args = ();
  ($typ3, $tok3) = &token(0); # lookahead
  if ($typ3 eq "key" && $tok3 eq "(") {
    &token(1); # consume '('
    ($typ3, $tok3) = &token(0); # lookahead
    if ($typ3 eq "key" && $tok3 eq ")") {
      # empty args
      &token(1); # consume ')'
    } else { # parse pars
      do {
        my ($typ5, $tok5) = &token(1);
        die "id expected in def, found $tok5 at $line"
          if $typ5 ne "id";
        push @args, $tok5;
        die "duplicated variable $tok5" if defined($var{$tok5});
        $var{$tok5} = "arg"; # register argument
        ($typ3, $tok3) = &token(1);
      } while ($typ3 eq "key" && $tok3 eq ",");
      die "expected closing par, found: $tok3 at $line"
        if $typ3 ne "key" || $tok3 ne ")";
    }
  }
  my @strs = ();
  ($typ3, $tok3) = &token(0); # lookahead
  while ($typ3 eq "str") { # optional comment string
    &token(1); # consume it
    push @strs, $tok3;
    ($typ3, $tok3) = &token(0); # lookahead
  }
  my ($typ6, $tok6) = &token(1);
  die "= expected in def, found $tok6 at $line"
    if $typ6 ne "key" || $tok6 ne "=";
  my $e = &parse_context();
  return ["def", $tok2, \@pars, \@args, \@strs, $e];
}

sub parse_let_rules() {
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok eq "let") {
    &token(1); # consume "let"
    my ($typ2, $tok2) = &token(1);
    die "id expected in let, found $tok2 at $line"
      if $typ2 ne "id";
    die "duplicated variable $tok2" if defined($glb{$tok2});
    # don't register yet, recursive let is disallowed
    my ($typ3, $tok3) = &token(1);
    die "= expected in let, found $tok3 at $line"
      if $typ3 ne "key" || $tok3 ne "=";
    %var = (); # reset let symbol table
    my $e1 = &parse_expr();
    $glb{$tok2} = "let"; # register let variable now
    my ($typ4, $tok4) = &token(1);
    die "'in' expected in let, found $tok4 at $line"
      if $typ4 ne "key" || $tok4 ne "in";
    my $e2 = &parse_let_rules();
    return ["let", $tok2, $e1, $e2];
  } else {
    return &parse_rules();
  }
}

sub parse_rules() {
  my ($typ1, $tok1) = &token(1);
  die "context name expected"
    if $typ1 ne "id";
  my ($typ, $tok) = &token(1);
  die "':' expected"
    if $typ ne "key" || $tok ne ":";
  %var = (); # reset let symbol table
  my $e1 = &parse_context();
  my @contexts = ($tok1, $e1); # ordered hash (list of key/val pairs)
  my %contexts = ($tok1 => $e1); # hash for local use only
  ($typ, $tok) = &token(1);
  while ($typ eq "key" && $tok eq ";") {
    ($typ1, $tok1) = &token(1);
    die "context name expected"
      if $typ1 ne "id";
    ($typ, $tok) = &token(1);
    die "':' expected"
      if $typ ne "key" || $tok ne ":";
    die "duplicated context name: $tok1"
      if exists($contexts{$tok1}); # uses the local hash
    %var = (); # reset let symbol table
    $e1 = &parse_context();
    push @contexts, $tok1, $e1;
    $contexts{$tok1} = $e1;
    ($typ, $tok) = &token(1);
  }
  die "garbage at end of program: $tok at $line"
    if $typ ne "eof";
  return \@contexts;
}

sub parse_context() {
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok eq "let") {
    &token(1); # consume "let"
    my ($typ2, $tok2) = &token(1);
    die "id expected in let, found $tok2 at $line"
      if $typ2 ne "id";
    die "duplicated variable $tok2" if defined($var{$tok2});
    # don't register yet, recursive let is disallowed
    my ($typ3, $tok3) = &token(1);
    die "= expected in let, found $tok3 at $line"
      if $typ3 ne "key" || $tok3 ne "=";
    my $e1 = &parse_expr();
    $var{$tok2} = "let"; # register let variable now
    my ($typ4, $tok4) = &token(1);
    die "'in' expected in let, found $tok4 at $line"
      if $typ4 ne "key" || $tok4 ne "in";
    my $e2 = &parse_context();
    return ["let", $tok2, $e1, $e2];
  } else {
    return &parse_expr();
  }
}

# left-recursive
sub parse_expr() {
  my $e1 = &parse_prod();
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok =~ /^[|]$/) {
    &token(1); # consume binary operator
    my $e2 = &parse_expr();
    return ["or", $e1, $e2];
  } else {
    return $e1;
  }
}

sub parse_prod() {
  my $e1 = &parse_comp();
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok =~ /^[&]$/) {
    &token(1); # consume binary operator
    my $e2 = &parse_prod();
    return ["and", $e1, $e2];
  } else {
    return $e1;
  }
}

sub parse_comp() {
  my $e1 = &parse_expr1();
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok =~ /^(>=!|<=|>=|>!|>!!|<|>)$/) {
    &token(1); # consume binary operator
    my $e2 = &parse_int();
    return [$tok, $e1, $e2];
  } else {
    return $e1;
  }
}

sub parse_int() {
  my $e1 = &parse_int1();
  my ($typ, $tok) = &token(0); # look ahead
  if ($typ eq "key" && $tok =~ /^[+-]$/) {
    &token(1); # consume binary operator
    my $e2 = &parse_int();
    return [$tok, $e1, $e2];
  } else {
    return $e1;
  }
}

sub parse_int1() {
  my ($typ, $tok) = &token(1);
  if($typ eq "int") {
    my $i = $tok;
    my ($typ2, $tok2) = &token(0);
    if ($typ2 eq "key" && $tok2 =~ /^(day|hr|min|sec)$/) {
      &token(1); # consume binary operator
      $i *= 1000;
      if ($tok2 eq "min") { $i *= 60; }
      elsif ($tok2 eq "hr") { $i *= 60 * 60; }
      elsif ($tok2 eq "day") { $i *= 24 * 60 * 60; }
    }
    return $i;
  } elsif ($typ eq "id") {
    die "unbound parameter $tok"
      if !defined($var{$tok}) || $var{$tok} ne "par";
    return $tok;
  # } elsif ($typ eq "str") {
  #   return "\"$tok\"";
  } else {
    die "expected int or id constant, found $tok at $line";
  }
}

# non left-recursive
sub parse_expr1() {
  my ($typ, $tok) = &token(1);
  die "empty expr" if !defined($typ) || $typ eq "eof";
  if ($typ eq "key") {
    if ($tok eq "~") {
      my $e = &parse_expr1();
      return ["not", $e];
    } elsif ($tok eq "(") {
      my $e = &parse_expr();
      my ($typ2, $tok2) = &token(1);
      die "expected closing par, found: $tok2 at $line"
        if $typ2 ne "key" || $tok2 ne ")";
      return $e;
    } elsif ($tok eq "true" || $tok eq "false") {
      return $tok;
    } else {
      die "expr starts with invalid key: $tok at $line";
    }
  } elsif ($typ eq "id") {
    my @pars = ();
    my ($typ2, $tok2) = &token(0); # lookahead
    if ($typ2 eq "key" && $tok2 eq "[") {
      &token(1); # consume '['
      do {
        my $e = &parse_int();
        push @pars, $e;
        ($typ2, $tok2) = &token(1);
      } while ($typ2 eq "key" && $tok2 eq ",");
      die "expected closing par, found: $tok2"
        if $typ2 ne "key" || $tok2 ne "]";
    }
    my $arglst = 0; # bool var: has arg list?
    my @args = ();
    ($typ2, $tok2) = &token(0); # lookahead
    if ($typ2 eq "key" && $tok2 eq "(") {
      &token(1); # consume '('
      $arglst = 1;
      ($typ2, $tok2) = &token(0); # lookahead
      if ($typ2 eq "key" && $tok2 eq ")") {
        # empty args
        &token(1); # consume ')'
      } else { # parse pars
        do {
          my $e = &parse_expr();
          push @args, $e;
          ($typ2, $tok2) = &token(1);
        } while ($typ2 eq "key" && $tok2 eq ",");
        die "expected closing par, found: $tok2"
          if $typ2 ne "key" || $tok2 ne ")";
      }
    }
    if ($#pars >= 0 || $arglst == 1) { # it's a call
      # TODO: allow forward references (delay check to code generation phase)
      my $op = $tok;
      if (!exists($predef{$op}) && !exists($def{$op}) && !exists($use{$op})) {
        die "undefined macro $op";
      } else { # check nb of pars & args
        my $type = exists($predef{$op})? $predef{$op}:
                    exists($def{$op})? $def{$op} : $use{$op};
        my $npars0 = $type->[0]; # expected
        my $nargs0 = $type->[1]; # expected
        my $npars = @pars; # provided
        my $nargs = @args; # provided
        if ($npars != $npars0 || defined($nargs0) && $nargs != $nargs0) {
          die "pars/args mismatch for $op\[$npars0\]($nargs0):\n" .
              "called: $op\[$npars\]($nargs)";
        }
      }
      return [$tok, \@pars, @args];
    } else { # it's a var ref
      # variables cannot use forward reference
      die "unbound variable $tok"
        if (!defined($var{$tok}) || $var{$tok} !~ /^arg|let$/) &&
            !defined($glb{$tok});
      return $tok;
    }
  } elsif ($typ eq "int") {
    die "unexpected int $tok at $line";
  } elsif ($typ eq "str") {
    return $tok;
  } else {
    die "strange token $tok:$typ";
  }
}

# returns, and optionally consumes the next token
sub token() {
  my ($consume) = @_;
  #print "called token($consume) on $line\n";
  return ("eof", undef) if !defined($line); # already at end of file
  while (1) {
    $line =~ s/^\s*//o; # whitespace
    $line =~ s/^#.*//o; # comments
    last if $line ne "";
    $line = <IN>;
    #print "read: $line";
    if (!defined($line)) {
      #print "line undef\n";
      return ("eof", undef);
    }
    chomp $line;
  }
  my $typ;
  my $tok;
  if ($line =~ /^(\d+)/) {
    ($typ, $tok) = ("int", $1);
  } elsif ($line =~ /^([][&|~(),;:=+-]|>=!|<=|>=|>!!|>!|<|>|(day|hr|min|sec|let|in|def|use|true|false)\b)/) {
    ($typ, $tok) = ("key", $1);
  } elsif ($line =~ /^([a-zA-Z_]\w*)/) {
    ($typ, $tok) = ("id", $1);
  } elsif ($line =~ /^("[^"]*")/) {
    ($typ, $tok) = ("str", $1);
  } else {
    die "unknown token at: $line\n";
  }
  if ($consume) {
    $line = substr($line, length($tok));
  }
  #print "token($consume): return ($typ, $tok); remains: $line\n";
  return ($typ, $tok);
}

sub print_ast() {
  my ($t) = @_;
  #print "called print_ast($t)\n";
  if (ref $t eq "ARRAY") {
    print OUT "[";
    for(my $i = 0; $i <= $#$t; $i++) {
      &print_ast($t->[$i]);
      if ($i < $#$t) {
        print OUT ", ";
      }
    }
    print OUT "]";
  } elsif (ref $t eq "") { # scalar
    if ($t =~ /^\d+$/) {
      print OUT "$t";
    } else {
      print OUT "\"$t\"";
    }
  }
}

# ----------------- generation ---------------------

sub gen_expr() {
  my ($t) = @_;
  #print "called print_ast($t)\n";
  if (ref $t eq "ARRAY") {
    die "gen_context([])" if $#$t < 0;
    my $op = $t->[0];
    if ($op =~ /^(>=!|<=|>=|>!|>!!|<|>|and|or|not)$/) {
      print OUT "[&";
      if ($op =~ /^(>=!|<=|>=|>!|>!!|<|>)$/) {
        print OUT
          $op eq "<="? "le":
          $op eq ">="? "ge":
          $op eq ">=!"? "geRT":
          $op eq "<"? "lt":
          $op eq ">"? "gt":
          $op eq ">!"? "gtRT":
          $op eq ">!!"? "gtRTa":
          die "unknown comparator $op";
        print OUT "(";
        &gen_expr($t->[2]);
        print OUT "), ";
        &gen_expr($t->[1]);
      } else {
        print OUT $op;
        for (my $i = 1; $i <= $#$t; $i++) {
          print OUT ", ";
          &gen_expr($t->[$i]);
        }
      }
      print OUT "]";
    } elsif ($op =~ /^[+-]$/) {
      &gen_expr($t->[1]);
      print OUT $op;
      &gen_expr($t->[2]);
    } else { # named op call
      my $pars = $t->[1];
      my @args = (@$t[2..$#$t]);
      # native macros first:
      if ($op eq "delay") { # unary op
        print OUT "[&$op(";
        &gen_expr($pars->[0]);
        print OUT "),";
        &gen_expr($args[0]);
        print OUT "]";
      } elsif ($op eq "wave") { # nullary op
        print OUT "[&$op(";
        &gen_expr($pars->[0]);
        print OUT ",";
        &gen_expr($pars->[1]);
        print OUT ",";
        &gen_expr($pars->[2]);
        print OUT ",";
        &gen_expr($pars->[3]);
        print OUT ")]";
      } else { # user-defined macros:
        print OUT "&$op(";
        my @lst = (@args, @$pars);
        my $first = 1;
        for my $x (@args, @$pars) {
          print OUT "," unless $first;
          $first = 0;
          &gen_expr($x);
        }
        print OUT ")";
      }
    }
  } elsif (ref $t eq "") { # scalar
    if ($t =~ /^\d+$/) {
      print OUT "$t";
    } elsif ($t =~ /^"/) {
      print OUT "$t";
    } elsif ($t eq "true" || $t eq "false") {
      print OUT "[&$t]"
    } else {
      print OUT "\$$t";
    }
  }
}

sub gen_context() {
  my ($t) = @_;
  my ($var, $val, $body) = &match_let($t);
  if (defined($var)) {
    print OUT "sub{";
    &gen_let($t);
    print OUT "}->()";
  } else {
    &gen_expr($t);
  }
}

sub match_let() {
  my ($t) = @_;
  if (ref $t eq "ARRAY" && $#$t >=1 && $t->[0] eq "let") {
    die "invalid let" if $#$t != 3;
    my (undef, $var, $val, $body) = @$t;
    return ($var, $val, $body);
  } else {
    return undef;
  }
}

sub gen_let() {
  my ($t) = @_;
  my ($var, $val, $body) = &match_let($t);
  if (defined($var)) {
    print OUT "my \$$var=";
    &gen_expr($val);
    print OUT "; ";
    &gen_let($body);
  } else {
    &gen_expr($t);
  }
}

sub gen_rules() {
  my ($p) = @_;
  print OUT "\n# User-defined contexts\n[\n";
  for (my $i = 0; $i < $#$p; $i += 2) { # iterate over key/val pairs
    my $k = $p->[$i];
    print OUT "\"$k\",\n";
    my $r = $p->[$i + 1];
    &gen_context($r);
    print OUT ",\n";
  }
  print OUT "]\n";
}

sub gen_let_rules_rec() {
  my ($t) = @_;
  my ($var, $val, $body) = &match_let($t);
  if (defined($var)) {
    print OUT "my \$$var=";
    &gen_expr($val);
    print OUT "; ";
    &gen_let_rules_rec($body);
  } else {
    &gen_rules($t);
  }
}

sub gen_let_rules() {
  my ($t) = @_;
  my ($var, $val, $body) = &match_let($t);
  if (defined($var)) {
    print OUT "# Global lets\n";
    &gen_let_rules_rec($t);
  } else {
    &gen_rules($t);
  }
}

sub gen_def() {
  my ($def) = @_;
  die "invalid def"
    if ref $def ne "ARRAY" || $#$def != 5;
  my (undef, $nm, $pars, $args, $strs, $body) = @$def;
  for my $str (@$strs) {
    $str =~ s/^"//; $str =~ s/"$//; # unquote
    print OUT "# $str\n";
  }
  print OUT "sub $nm() {\n";
  print OUT "  my (";
  my @vars = (@$args, @$pars);
  for (my $i = 0; $i <= $#vars; $i++) {
    print OUT "\$$vars[$i]";
    print OUT "," if $i < $#vars;
  }
  print OUT ") = \@_;\n";
  # print OUT "  return ";
  # &gen_context($body);
  print OUT "  ";
  &gen_let($body);
  print OUT ";\n";
  print OUT "}\n";
}
